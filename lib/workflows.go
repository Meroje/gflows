package lib

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/jbrunton/gflows/config"
	"github.com/jbrunton/gflows/content"
	"github.com/jbrunton/gflows/diff"
	"github.com/jbrunton/gflows/logs"
	"github.com/jbrunton/gflows/styles"
	"github.com/logrusorgru/aurora"

	fdiff "github.com/go-git/go-git/v5/plumbing/format/diff"
	"github.com/google/go-jsonnet"
	statikFs "github.com/rakyll/statik/fs"
	"github.com/spf13/afero"
)

// WorkflowDefinition - definitoin for a workflow defined by a GFlows template
type WorkflowDefinition struct {
	Name        string
	Source      string
	Destination string
	Content     string
	Status      ValidationResult
}

func getWorkflowSources(fs *afero.Afero, context *config.GFlowsContext) []string {
	files := []string{}
	err := fs.Walk(context.WorkflowsDir, func(path string, f os.FileInfo, err error) error {
		ext := filepath.Ext(path)
		if ext == ".jsonnet" || ext == ".libsonnet" {
			files = append(files, path)
		}
		return nil
	})

	if err != nil {
		panic(err)
	}

	return files
}

func getWorkflowTemplates(fs *afero.Afero, context *config.GFlowsContext) []string {
	sources := getWorkflowSources(fs, context)
	var templates []string
	for _, source := range sources {
		if filepath.Ext(source) == ".jsonnet" {
			templates = append(templates, source)
		}
	}
	return templates
}

func getWorkflowName(workflowsDir string, filename string) string {
	_, templateFileName := filepath.Split(filename)
	return strings.TrimSuffix(templateFileName, filepath.Ext(templateFileName))
}

func createVM(context *config.GFlowsContext) *jsonnet.VM {
	vm := jsonnet.MakeVM()
	vm.Importer(&jsonnet.FileImporter{
		JPaths: context.EvalJPaths(),
	})
	vm.StringOutput = true
	return vm
}

// GetWorkflowDefinitions - get workflow definitions for the given context
func GetWorkflowDefinitions(fs *afero.Afero, context *config.GFlowsContext) ([]*WorkflowDefinition, error) {
	templates := getWorkflowTemplates(fs, context)
	definitions := []*WorkflowDefinition{}
	for _, templatePath := range templates {
		vm := createVM(context)
		workflowName := getWorkflowName(context.WorkflowsDir, templatePath)
		input, err := fs.ReadFile(templatePath)
		if err != nil {
			return []*WorkflowDefinition{}, err
		}

		destinationPath := filepath.Join(context.GitHubDir, "workflows/", workflowName+".yml")
		definition := &WorkflowDefinition{
			Name:        workflowName,
			Source:      templatePath,
			Destination: destinationPath,
			Status:      ValidationResult{Valid: true},
		}

		workflow, err := vm.EvaluateSnippet(templatePath, string(input))
		if err != nil {
			definition.Status.Valid = false
			definition.Status.Errors = []string{strings.Trim(err.Error(), " \n\r")}
		} else {
			meta := strings.Join([]string{
				"# File generated by gflows, do not modify",
				fmt.Sprintf("# Source: %s", templatePath),
			}, "\n")
			definition.Content = meta + "\n" + workflow
		}
		definitions = append(definitions, definition)
	}

	return definitions, nil
}

// UpdateWorkflows - update workflow files for the given context
func UpdateWorkflows(fs *afero.Afero, context *config.GFlowsContext) error {
	validator := NewWorkflowValidator(fs, context)
	writer := content.NewWriter(fs, logs.NewLogger(os.Stdout))
	definitions, err := GetWorkflowDefinitions(fs, context)
	if err != nil {
		return err
	}
	valid := true
	for _, definition := range definitions {
		details := fmt.Sprintf("(from %s)", definition.Source)
		if definition.Status.Valid {
			schemaResult := validator.ValidateSchema(definition)
			if schemaResult.Valid {
				writer.UpdateFileContent(definition.Destination, definition.Content, details)
			} else {
				writer.LogErrors(definition.Destination, details, schemaResult.Errors)
				valid = false
			}
		} else {
			writer.LogErrors(definition.Destination, details, definition.Status.Errors)
			valid = false
		}
	}
	if !valid {
		return errors.New("errors encountered generating workflows")
	}
	return nil
}

// ValidateWorkflows - returns an error if the workflows are out of date
func ValidateWorkflows(fs *afero.Afero, context *config.GFlowsContext, showDiff bool) error {
	validator := NewWorkflowValidator(fs, context)
	logger := logs.NewLogger(os.Stdout)
	definitions, err := GetWorkflowDefinitions(fs, context)
	if err != nil {
		return err
	}
	valid := true
	for _, definition := range definitions {
		fmt.Printf("Checking %s ... ", aurora.Bold(definition.Name))

		if !definition.Status.Valid {
			fmt.Println(styles.StyleError("FAILED"))
			fmt.Println("  Error parsing template:")
			logger.PrintStatusErrors(definition.Status.Errors, false)
			valid = false
			continue
		}

		schemaResult := validator.ValidateSchema(definition)
		if !schemaResult.Valid {
			fmt.Println(styles.StyleError("FAILED"))
			fmt.Println("  Schema validation failed:")
			logger.PrintStatusErrors(schemaResult.Errors, false)
			valid = false
		}

		contentResult := validator.ValidateContent(definition)
		if !contentResult.Valid {
			if schemaResult.Valid { // otherwise we'll duplicate the failure message
				fmt.Println(styles.StyleError("FAILED"))
			}
			fmt.Println("  " + contentResult.Errors[0])
			fmt.Println("  â–º Run \"gflows workflow update\" to update")
			valid = false

			if showDiff {
				fpatch, err := diff.CreateFilePatch(contentResult.ActualContent, definition.Content)
				if err != nil {
					panic(err)
				}
				message := strings.Join([]string{
					fmt.Sprintf("src: <generated from: %s>\ndst: %s", definition.Source, definition.Destination),
					fmt.Sprintf(`This diff shows what will happen to %s if you run "gflows update"`, definition.Destination),
				}, "\n")
				patch := diff.NewPatch([]fdiff.FilePatch{fpatch}, message)
				PrettyPrintDiff(patch.Format())
			}
		}

		if schemaResult.Valid && contentResult.Valid {
			fmt.Println(styles.StyleOK("OK"))
			for _, err := range append(schemaResult.Errors, contentResult.Errors...) {
				fmt.Printf("  Warning: %s\n", err)
			}
		}
	}
	if !valid {
		return errors.New("workflow validation failed")
	}
	return nil
}

// InitWorkflows - copies g3ops workflow sources to context directory
func InitWorkflows(fs *afero.Afero, context *config.GFlowsContext) {
	generator := content.WorkflowGenerator{
		Name: "gflows",
		Sources: []string{
			"/workflows/common/steps.libsonnet",
			"/workflows/common/workflows.libsonnet",
			"/workflows/config/git.libsonnet",
			"/workflows/gflows.jsonnet",
			"/config.yml",
		},
	}
	writer := content.NewWriter(fs, logs.NewLogger(os.Stdout))
	sourceFs, err := statikFs.New()
	if err != nil {
		err = writer.ApplyGenerator(sourceFs, context, generator)
	}
	if err != nil {
		fmt.Println(styles.StyleError(err.Error()))
	}
}
